# 360 Cafe and Outlets - Software Requirements Specification (SRS) Detailed Supplement

## 1.1.3 Document Conventions
This document strictly adheres to the IEEE 830-1998 standard for Software Requirements Specifications to ensure consistency and clarity across all stakeholder communications. All requirement statements are written using imperative modality (e.g., "The system shall...") to denote mandatory features, while terms like "should" or "may" indicate desirable but optional capabilities. Specialized terminology generally follows standard software engineering definitions, but project-specific terms (like "Shop Owner" vs "Admin") are capitalized throughout to distinguish them as specific user roles. Code references, API endpoints, and file paths are consistently formatted in `monospaced font` to visually separate implementation details from functional descriptions, aiding developers and testers in quickly scanning for technical specifications.

## 1.1.6 Intended Audience and Reading Suggestions
This document is prepared to serve a diverse group of stakeholders, each with unique needs. **Developers** (Backend and Frontend) should focus primarily on Sections 1.3 and 1.4 to understand the specific API contracts, data flow requirements, and structural constraints of the microservices architecture. **Project Managers** are advised to review Section 1.2 to align project milestones with the detailed feature breakdown and verify that the scope remains within the agreed boundaries. **Quality Assurance (QA) Testers** should utilize the behavioral diagrams and system feature descriptions in Section 1.4 to construct comprehensive test plans and validation matrices. Finally, **Stakeholders and Investors** should read the executive summary and product perspective in Section 1.2 to gain a high-level understanding of the product's market fit and operational value without getting bogged down in technical minutiae.

## 1.2 Overall descriptions

### 1.2.1 Product Perspective
"360 Cafe and Outlets" is conceived as a localized, gap-filling solution for the food and beverage market in Turbat, a region currently underserved by major global delivery platforms. Unlike generic e-commerce applications, this system is specifically architected to handle the nuances of local cafe operations, offering a digitized bridge between traditional brick-and-mortar outlets and a growing digital-native customer base. The system operates as a self-contained ecosystem employing a distributed **Microservices Architecture**, which allows for modular deployment and independent scaling of authentication, user management, and order processing services. It is designed to interface seamlessly with existing internet infrastructure in the region, providing a reliable platform for ordering even in environments with variable network stability.

### 1.2.2 Product Features
The platform offers a comprehensive suite of features designed to digitize the entire food ordering workflow. For **User Management**, it provides a secure, token-based authentication system that supports distinct roles, ensuring that customers cannot access administrative dashboards. The **Shop Management** module empowers owners with real-time controls, allowing them to instantly toggle their shop's visibility (Open/Closed) based on kitchen load, a critical feature for maintaining service quality. The **Product Catalog** allows for rich media management, where owners can upload high-quality images and categorize items to create appetizing digital menus. The **Order Lifecycle** management is the core engine, tracking every stage of an order from placement to completion with live status updates pushed to all parties. Finally, the **Review System** introduces a meritocratic quality control layer, where verified purchases allow customers to rate shops, fostering a trust-based marketplace.

### 1.2.3 User Classes and Characteristics
The **Customer** class represents the end-users of the mobile application; they are typically non-technical users who value speed, visual appeal, and ease of navigation. They expect the application to offer intuitive discovery of food production and a frictionless checkout process with immediate feedback on their order status. The **Shop Owner** class consists of local business operators who may primarily use the application on tablets or smartphones in a busy kitchen environment. They require high-contrast, easily readable interfaces with large touch targets and reliability is their top priority—they cannot afford to miss an order notification. The **System Administrator** is a highly technical user responsible for the platform's health; their dashboard focuses on metrics, user dispute resolution, and system-wide configuration, requiring detailed logging and advanced filtering capabilities.

### 1.2.4 Operating Environment
The client-side ecosystem acts as the primary interface for users, consisting of a cross-platform mobile application built with Flutter that must run smoothly on Android devices (targeting API Level 21 and above) and iOS devices (iOS 12+). For administrative and shop management tasks, a responsive web portal is optimized for modern desktop browsers including Chrome, Firefox, and Safari. On the server side, the backend logic executes within a **Node.js (v16+)** runtime environment, leveraging its non-blocking I/O for high-performance handling of concurrent requests. Data persistence is managed by a **PostgreSQL** database, chosen for its ACID compliance to ensure transactional integrity for financial and order data. The entire infrastructure is container-ready, capable of running on scalable cloud instances (e.g., AWS EC2 or DigitalOcean Droplets) running Linux distributions.

### 1.2.5 Design and Implementation Constraints
The system's design is heavily constrained by the decision to adopt a strict **Microservices Architecture**. This mandates that each service (Auth, User, Shop, Order) must remain completely decoupled; they cannot share database tables or access each other's internal memory, communicating strictly via synchronous REST APIs or asynchronous event buses. Network connectivity in the target deployment region (Turbat) imposes another significant constraint, requiring the mobile application to be resilient to high latency and intermittent packet loss, necessitating efficient payload design (minimized JSON) and aggressive caching strategies for static assets like images. Additionally, strict **Security Protocols** dictate that all Personally Identifiable Information (PII) must be encrypted at rest and in transit, and user passwords must be hashed using industry-standard algorithms like bcrypt to prevent data breaches.

### 1.2.6 Assumptions and Dependencies
The project relies on several key assumptions for its successful operation, primarily that Shop Owners will possess and maintain functional smartphones or tablets with an active internet connection during all business hours to receive orders. It is also assumed that end-users will grant the necessary permissions (Location, Notifications) to the mobile application to enable core discovery features. Critical external dependencies include the availability and accuracy of third-party **Map/Geolocation APIs** (like Google Maps or Mapbox) for calculating delivery distances and locating shops. Furthermore, the system's uptime and reliability are intrinsically linked to the service level agreements (SLAs) of the chosen cloud hosting provider and database hosting service, assuming a minimum availability of 99.9%.

## 1.3 External Interface Requirements

### 1.3.1 Hardware Interfaces
The system interacts directly with specific hardware components on client devices to function correctly. It requires access to the **Mobile Device Camera** and gallery on Shop Owner devices to facilitate the real-time capturing and uploading of product and storefront images. For the location-based features to work, the application interfaces with the device's **GPS Module** to obtain precise latitude and longitude coordinates, which are essential for sorting shops by distance and estimating delivery times. The application also effectively utilizes **Local Device Storage** (flash memory) to cache frequently accessed data such as menu images, user preferences, and authentication tokens, thereby reducing data usage and improving load times on subsequent launches.

### 1.3.2 Software Interfaces
The application requires seamless integration with the underlying mobile Operating Systems (Android and iOS) to access native file pickers for image uploads and to register background services for push notifications. At the data layer, the backend services maintain persistent TCP/IP connections with the **PostgreSQL Database**, utilizing connection pooling to manage load efficiently. Crucially, all external client communication is funneled through a centralized **API Gateway**, which listens on port 3000. This software intermediary handles request routing, load balancing, and preliminary security checks before proxying traffic to the internal microservices (ports 3001-3005) via internal HTTP/1.1 calls, serving as the single entry point for the entire software ecosystem.

## 1.4 System Features

### 1.4.1 System Feature: Real-time Shop Status Toggle
This feature provides Shop Owners with the critical ability to manually override their shop's automated schedule and declare the shop as "Open" or "Closed" in real-time. This is essential for handling unexpected events such as running out of stock, kitchen emergencies, or sudden closures. When the owner activates the toggle switch on their dashboard, the app transmits a secure PATCH request to the `/shops/:id/status` endpoint. The backend processes this request, updates the persistence layer, and broadcasts the new status. Consequently, the Customer App immediately reflects this change by graying out the shop or updating its label, and the backend enforces a rule to reject any new orders placed while the status is "Closed," thereby preventing customer dissatisfaction due to unfulfillable orders.

### 1.4.2 Behavioral Diagram (State Chart for Order)
The lifecycle of an order within the system is modeled as a finite state machine to ensure deterministic behavior. The process begins in the **Placed** state when a customer confirms an order. From here, it awaits a manual intervention from the Shop Owner, who can transition it to either **Accepted** (validating the order) or **Rejected** (if items are unavailable). Once accepted, the order moves to the **Preparation** phase, representing the physical cooking or packaging time. Upon completion, the status is updated to **Ready**, notifying the customer or driver that pickup is available. Finally, the order reaches the **Completed** terminal state once handover is verified. The system also accounts for a **Cancelled** state, which can be triggered by the user within a short grace period before the shop accepts the order.

## 1.5 Other Non-functional Requirements
Non-functional requirements define the quality attributes of the system. **Performance** goals mandate that all read-heavy API operations, such as fetching a menu or shop list, must return a response within 200 milliseconds under normal load conditions to ensure a "snappy" user experience. **Scalability** is addressed through the decoupled microservices design, which permits specific high-traffic components, like the Order Service, to be replicated or allocated more resources independently during peak dining hours without redeploying the entire system. **Reliability** strategies include graceful degradation logic; if the database becomes temporarily unreachable, the application should display cached data to the user rather than crashing. **Usability** requirements dictate that all interface text be in clear, simple English, and that universal iconography (e.g., green circles for Open, red for Closed) is used to ensure the app is accessible to a diverse user base with varying levels of literacy.

## Abstraction
The "360 Cafe and Outlets" project is effectively an abstraction layer that simplifies the complex interactions of a hyperlocal marketplace into manageble digital components. By abstracting the chaotic reality of food service—the shouting in kitchens, the navigation of streets, the handling of cash—into a structured three-tier interaction model, the system introduces order and efficiency. It decouples the *consumption layer* (the Customer App) from the *management layer* (the Shop Owner App) and the *processing layer* (the Backend Services). This separation of concerns means that a Shop Owner does not need to know how a Customer's payment is processed, only that the order is "Paid". Similarly, the technical complexities of database transactions, authentication tokens, and API routing are hidden behind intuitive, user-friendly interfaces. This high-level abstraction allows non-technical stakeholders to leverage sophisticated, enterprise-grade technology to grow their local businesses without needing to understand the underlying mechanics.
